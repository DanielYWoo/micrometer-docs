Micrometer Tracing comes with a `micrometer-tracing-test` and `micrometer-tracing-integration-test` modules.
For the integration tests it provides a `SampleTestRunner` mechanism that you can hook into your samples.
It will

* Configure a OpenZipkin Brave Tracer
** Set it up with Tanzu Observability by Wavefront Reporter
** Set it up with OpenZipkin Zipkin Reporter
* Configure a OpenTelemetry Tracer
** Set it up with Tanzu Observability by Wavefront Exporter
** Set it up with OpenZipkin Zipkin Exporter
* Run all the combinations above against the user code and running infrastructure

For unit tests it provides a `SimpleTracer` that is a test implementation of a `Tracer`.

== Installing

The following example shows the required dependency in Gradle (assuming that Micrometer Tracing BOM has been added):

[source,groovy,subs=+attributes]
----
testImplementation 'io.micrometer:micrometer-tracing-test' // for unit tests
testImplementation 'io.micrometer:micrometer-tracing-integration-test' // for integration tests
----

The following example shows the required dependency in Maven (assuming that Micrometer Tracing BOM has been added):

[source,xml,subs=+attributes]
----
<dependency>
  <groupId>io.micrometer</groupId>
  <artifactId>micrometer-tracing-test</artifactId> <!-- For unit tests -->
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>io.micrometer</groupId>
  <artifactId>micrometer-tracing-integration-test</artifactId> <!-- For integration tests -->
  <scope>test</scope>
</dependency>
----

== Running

The following example shows how you can run your code to test against running Tanzu Observability by Wavefront instance and Zipkin.

[source,java,subs=+attributes]
-----
class TestTest extends SampleTestRunner {

	TestTest() {
		super(SamplerRunnerConfig
				.builder()
				.wavefrontApplicationName("my-app")
				.wavefrontServiceName("my-service")
				.wavefrontToken("...")
				.wavefrontUrl("...")
				.zipkinUrl("...") // defaults to localhost:9411
				.build());
	}
	
	// Here you can add your own custom handlers in the desired order
	@Override
	public BiConsumer<BuildingBlocks, LinkedList<TimerRecordingHandler>> customizeTimerRecordingHandlers() {
		return (bb, timerRecordingHandlers) -> {
			timerRecordingHandlers.add(timerRecordingHandlers.size() - 1, new ReactorNettyTracingRecordingHandler(bb.getTracer()));
			timerRecordingHandlers.addFirst(new ReactorNettyHttpClientTracingRecordingHandler(bb.getTracer(), bb.getHttpClientHandler()));
			timerRecordingHandlers.addFirst(new ReactorNettyHttpServerTracingRecordingHandler(bb.getTracer(), bb.getHttpServerHandler()));
		};
	}

	// Here you can pass the code you want to run the instrumentation against
	@Override
	public BiConsumer<Tracer, MeterRegistry> yourCode() {
		// example for testing Reactor Netty
		byte[] bytes = new byte[1024*8];
		Random rndm = new Random();
		rndm.nextBytes(bytes);
		return (tracer, meterRegistry) ->
				HttpClient.create()
						.wiretap(true)
						.metrics(true, Function.identity())
						.post()
						.uri("https://httpbin.org/post")
						.send(ByteBufMono.fromString(Mono.just(new String(bytes))))
						.responseContent()
						.aggregate()
						.block();
	}
}
-----
